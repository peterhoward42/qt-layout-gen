------------------------------------------------------------------------------
Structure and Design
------------------------------------------------------------------------------

Single package

Flat module structure

Modules
    api
    implementation
    fileio
    inputmodel
    parser
    introspection

File structure
    entrypoint
        readme
        src
        docs
        testdata

------------------------------------------------------------------------------
API
------------------------------------------------------------------------------

input text interpretation and nomenclature

    The input text is seen as a single homogeneous stream of text even when it
    is derived by aggregating multiple sources.

    It will always be divided into units to consume by a splitting process
    that ignores newline characters. It will split at every
    instance of for example "HBOX:fred". I.e. one of the agreed keywords,
    followed by a colon, followed by non space characters.

    This means that long lists of children can span multiple lines if
    required. It also means that quite long python string literals that span
    multiple lines can be used as input. When the chunks have been derived
    from files, that chunk will carry around with it the filename and line
    number at which the keyword was found - to provide this information when
    reporting errors.

constants

    HBOX VBOX STACK TAB SPLIT 

types

    BuiltLayouts    // The set of QLayouts produced, structured as
                    // a dictionary of every layout or widget produced
                    // by the build process - keyed on the names used
                    // for them in the input text.


                    // Nb a side effect of this data structure is that
                    // references are generated for every object. Which
                    // protects them from garbage collection for as
                    // long as a reference exists to the BuiltLayouts
                    // object itself.
                    
    BuildError      // A list of error reporting strings a bit like a
                    // stack trace.
                    // Provides these either as a list or a single string,
                    // embedded newlines.

functions

    // Highest level api function, consumes all files found recursively

        built_layouts, build_err = make_layouts_from_directory(path)

    // Or for just a single file

        built_layouts, build_err = make_layouts_from_file(path)

    // Or decoupled from file system - suitable for simple inline definition
    // of input text, and to decouple testing from dependency on file system.
    // Unsuitable for large text inputs because of the intrinsic limitations
    // on reporting the context of errors.

        built_layouts, build_err = make_layouts_from_text(one_big_string)

Nb. We favour explicit error return value over raising exceptions.

------------------------------------------------------------------------------
Implementation psuedo code
------------------------------------------------------------------------------

types

    textFragment    // Holds one of the strings found by splitting the input
                    // as described above. Will produce a parsedNodeSpec when
                    // parsed.  Also carries with it the file and line number 
                    // source information when available.
    
    parsedNodeSpec  // The specification of a layout node in terms of
                    // the required type for the parent, the name to give it
                    // and the list of strings that must be resolved to
                    // provide the children. Carries also a reference to the
                    // textFragment it is based on, to support error reporting.


    nodeTree        // Used to assemble tree graphs of parsedNodeSpecs based
                    // by holding references for each parent to its children.
            

functions

    // Makes a list of file paths
    all_files, err = recursive_search_directory(path)

    // Makes one big list of textFragments
    textFragments, err = extrace_fragments_from_files(all_files) 

    // Parse the input text into a clean, machine readable and structured
    // set of records
    // including error detection (at the lexical, per-record level)
    parsedNodeSpecs, err = parse_node_specs(textFragments)

        // Helper for just one node
        parseNodeSpec, err = parse_node_spec(textFragment)

    built_layouts, err = build_layouts(parsedNodeSpecs)

        // Builds the nodeTree implied by the list of parsedNodeSpecs
        // provided. More precisely in the plural, because the set of
        // parsedNodeSpecs can imply multiple, independent trees.
        // The returned value is a dictionary keyed on the name given for
        // the root elements in the text input.

        tree_topology, err = trace_out_tree_topology(parsedNodeSpecs)

        layouts, err = build_tree(tree_topology)

------------------------------------------------------------------------------
Test Planning
------------------------------------------------------------------------------

o  is an identifier utility test

o  error construction and query

o  recursive_search_directory(path)
    o  gets files
    o  recurses
    o  excludes directory elements
    o  stops at limit
    o  barfs when none found

o  extract fragments files
    o  at string level first
        o  as would be found in typ file
        o  as would be found in typ string literal
        o  error handling
        o  no keywords found
        o  keyword not followed by colon
        o  colon not followed by parent name
        o  all that not followed by at least one name field
    o  from file works and errors
    o  from files works and errors

o  parse_node_specs

    o  from single fragment helper first
        o  error if non reg keyword
        o  error if name not ok identifier
        o  error if no children cited
        o  error if children not identifiers or <>
        o  does harvest legit input
    o  now multiple
        o  error if multiple not given
        o  error if dupe name targets found
        o  harvests basics

o  trace out tree
    o
    o  error if less < 1 node provided
    o  can deal with v simple case of one tree 3 level
    o  can deal with v simple case of two tree 3 level
    o  error if any node left unconsumed

o  attempt to make a qt widget or layout primitive
    o  cannot be imported
    o  cannot be build with default constructor
    o  returns what should when correct

o  gc finder
    o  does class qualification right
    o  rejects when duplicate
    o  when at module level this module level
    o  when in class var
    o  when instance attribute
    o  when in local var

o  reconcile child name
    o  when is known to tree
    o  when is constructable Qt prim
    o  when is provided in injected map
    o  when is Qt widget or layout primitive
    o  when is disvovered in gc
    o  check precedence
    o  check err reporting

o  build one tree
    o  tiny example 
        o  makes right parent with right name
        o  gives it right children
        o  augments map io

o  build trees
    o  not much else on top
