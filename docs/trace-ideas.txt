# Trace Ideas

## Requirements
- When you save the input file, you see either the new GUI or the error.
- When it shows you a GUI, it stays up until there is a new viable one.
- It is easy to shut down.
- It shows it is still alive after each attempt.

## Architectural Needs
- The building and showing needs to be done in the main thread.
- The polling loop probably needs sleeps() in it, so should be in a separate
  thread.

## Fundamental Logic
- A continuous loop to detect a more recent file than that last consumed.
- Attempt to build, catching exceptions.
- When succeed, show new gui and ditch previous one.
- When fail, print error and comfort message that still alive.


## Timing problems with Getting mtime 
Editors can lock files during save, which cause reading mtime to raise
exceptions. These must be swallowed and re-enter the polling loop.

## Main Window Lifecycle Challenges
Is it sufficient for the old top level widget to be released to GC? Or must we
hide() it.

## Threading Design

Make it a discrete program that takes command line argument as the input file.
The main program will use a class instance to do what follows below.

The main program starts by creating a Qt app and eventually drops into its own
event loop. But not before creating the background polling loop.

It creates the polling loop by creating and launching a monitor thread.
The monitor thread does not have an event loop. The main program will provide
a QEvent handler to receive 'try now' mandates. The monitor will send an event
back to the main thread when it wants to tell it to 'try now', using notify().
The object doing the work in the main thread is passed into the monitor
thread's constructor.

The monitor will keep track of the input file timestamp that belongs to the
most recently emitted try now event. It will then sit in a loop measuring the
file's mtime, and when one arrives that is newer than the most recently
emitted, it will emit the try now event, and obviously update the most
recently tried time. It might be good for it to sleep for <n> seconds after
each measurement of mtime to avoid needless cpu load and IO.

The main thread's try now event handler will implement the logic to attempt
the build and either show() the result, or show the error message.
