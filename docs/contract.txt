Contract
--------

Overview
--------

Input comprises a set of input records like this:

    my_page:VBOX header_row body footer_row

This one means - "make me a QVBoxLayout and call it 'my_page'. Then treat the
things on the right as children that should be added to the layout.

It tries to resolve the things on the right to things on the left somewhere
else in the input. Like this fragment that provides a definition for
'header_row' in the first example:

    header_row:HBOX left_bit middle_bit right_bit

The left hand part ALWAYS creates a QLayout or QWidget. (Or subclass)

The right hand part comprises words that define what should be added to the
thing on the left as its children.

These are usually names of things which have been created by a left hand part
in one of the other input records.

If a child name resolves to something that is a QWidget, the system will
speculatively try calling addWidget(widget) and also addTab(widget) on the
parent. (Parent is usually a QLayout in this case, but TabbedWidget also works
as a parent).

If the child name resolves to something that is a QLayout, the system will
speculatively try calling addLayout(), and setLayout() on the parent. This
caters for adding child layouts to parent layouts, and also setting the layout
for a parent that is a widget.

If there is only one child name specified, and it does not resolve to a
QLayout/QWidget, it is taken to be text that can be used in a call to setText()
on the parent. Useful for QPushButtons and QLabels etc.

Input Record - Sources
----------------------

The system consumes records at run time, and these can be provided by:
1) A multi-line string.
2) A file.
3) A directory.

The first case is useful for simple layouts and layout fragments and lets
you have the input text right next to the code that uses it.

In the third case, all the files in the directly and sub directories are
consumed recursively. This is intended for large complex layouts where it is
valuable to use multiple files and a hiearchy to tame complexity and to make
it easier to change small parts in isolation.

The second case is a half-way house between the two.

The order in which the system encounters the records does not matter in any of
these cases. It amalgamates all the input records together internally, before
trying to resolve the cross references.

Parsing Contract
----------------

Newline characters are not significant in the parsing other than just another
form of whitespace. The parsing specification is listed below - but note that
it means that records can span multiple lines - which is useful for long lists
of children.

The parsing begins by splitting the input text into 'words', simply by treating
whitespace as the delimiters. So this will include child names, but also the
compound words that include a colon like 'my_page:VBOX'. A record is then defined
to start at a colon-word, and to include all the words that follow up to the next
colono-word (or end of file).

Using Comments in the Input
---------------------------

You can incorporate comments into the input with parenthesis.

    ( I am a comment )

These must start and end on the same line, but apart from that, they can
go anwhere, and are conceptually removed completely from the input
before the parsing described above sets to work. Very simple implementation,
no nesting or escaping is provided / allowed.


What can it make (apart from QBoxLayouts)
-----------------------------------------
To complete the list of keywords you can use on the left, they are:

    VBOX, HBOX, STACK, TAB, SPLIT 

    (The last two of these are QWidgtet, not QLayouts.)

These are just short forms for the really common Qt classes.
You could have written it longhand instead:

    my_page:QVBoxLayout          row_a         row_b           row_c

You can put the name of any Qt Widget or Layout - but it is up to you to
make sure that it supports addWidget(), addLayout(), setLayout(), addTab()
or setText().

This is how you add text to labels and buttons:

        header_rows:HBOX left_bit my_label right_bit
        my_label:QLabel with-this-text

Accessing the layouts and widgets created
------------------------------------------
You will invariably need to access the components incorporated into the layouts
once they have been created, to do things like connecting signals and setting
styles for example.

So the builder exposes them like this:

    layouts_built how did I do it?

Note this implies all the names you use on the left hand side in your input 
text must be globally unique. The builder will tell you politely when this
is not so. This is unfortunate, but a deliberate trade-off. We could have
avoided the problem by exposing the components hierarchically:

    layouts_built.my_page.header_row

But that creates unecessary work later, if you decide to move things around in
the hiearchy - and we wanted to make sure that was easy to do.

Not just one big layout
-----------------------
Sometimes you'll want to get the builder to make a set of layouts and sub
layouts that you'll combine manually later. Particlarly when you're
introducing it incrementally to existing code.

You don't have to do anything extra to achieve this - the number of layouts
you get is defined by the connectivities you've implied in your input text.
If it all resolves to one big tree then you get one layout. If it resolves to
two seperate trees then you get two trees. You access them as described above:

    layouts_built.my_main_layout
    layouts_built.my_auxillary_layout

If you don't get what you expect, you can ask the builder to show you how it
traced out everything. This produced a string representation of the tree(s) it
deduced.

    layouts_built.get_layout_hierarchy_map()


Using widgets you made earlier (or layouts)
-------------------------------------------
Many custom widgets and layouts need to be constructed and instantiated by
hand. And when you're introducing the builder to existing code bases
incrementatlly, your program will likely want to instantiate some you created
outside of the builder, but then have the builder use them.

There is a way to specify on the left hand side, that the builder should go
off and find a pre-existing object that you've pre-instantiated somewhere
else in your program.

    my_page:Find:CustomLayout header_row body footer_row

This behaviour kicks in when your left hand side has two colons in and the
middle word is 'Find'.

The builder will consider all the objects that are already instantiated in your
program which are of the CustomLayout class. It will then look for one that
you have referenced with a variable or attribute called 'my_page'. For example
Somewhere else in your program you wrote:

    my_page = CustomLayout(arg1, arg2, etc), or
    some_object.my_page = CustomLayout(arg1, arg2, etc), or

If more than one object qualifies - the builder will object politely.

Reserved Child Names
--------------------
The system reserves (some) names for children to have a special meaning.

You can get stretch added to a QBoxLayout (layout.addStretch()), but using
the reserved child name: '<>'.

    my_box:HBOX foo bar <> baz

I want spaces in my label strings
---------------------------------
The parsing contract means that you cannot directly include spaces in the text
you provide for QLabels / Buttons etc.

But if you include double underscores in these strings, then the
system will automatically substitute a space:

    QLabel:my_label this__has__spaces__in


