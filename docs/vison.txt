Introduction
------------
Most complex Qt GUIs are build from a topological hierarchy dominated by these:
    o  Layouts
        o  QHBoxLayout
        o  QVBoxLayout
        o  QStackedLayout
    o  Widgets
        o  QSplitter    
        o  QTabWidget

Plus Qt primitive widgets like QButton and QLabel at the leaf-level.
And layout trees will of course contain custom QWidget subclasses, which each
having their own QLayout assigned to them. There is no semantic distinction
between the top level layout hierarchy and these sub layouts. This solution
is interested in making it easy to build them for both contexts.

All of these are parent-child containers in essence that take QWidgets, or
subsidiary QLayouts as their children. In what follows we will simply refer
to parents and children - and take those terms to mean the objects in
QLayout/QWidget parent-child hierarchies.

So we can sensibly think of an arbitrarily deep nested parent-child
containership hierarchy. It might be quite feasible for the entire app GUI
topological hierarchy to be defined in this way, or maybe major chunks
of it.

It would be very useful if arbitrarily complex trees or sub trees could be
expressed in a VERY simple and VERY terse text format, and have some software
generate the layouts automatically.

fart got to here

because this would be very much less
verbose and easier to write than the corresponding code, and it would also make
it VERY much easier to rearrange or extend a GUI with no side effects or knock-on
work.

We hypothesise a runtime builder system that is capable of building and
instantiating the tree thus defined from text input provided at runtime. 

We prefer a runtime solution over a code-generator for two reasons.
Firstly, because it preserves a single source of truth for the intent, and 
avoids bugs arising from stale generated code lying around. Secondly, it
produces live object references that you can use in the rest of your program, and
are hence in no way locked-in to this method for generating the GUI - you can
mix and match and introduce it incrementally to existing code.

About the Input Text
--------------------
Consider this fragment:

    VBOX:my_page          header_row    body            footer_row

It means - "make me a QVBoxLayout and call it 'my_page'. Then treat the things
on the right as children that should be added to the layout.

It demands that the things on the right can be resolved to things on the left
somewhere else in the input. Like this one that defines what header_row means.

    HBOX:header_row       left_bit      middle_bit      right_bit

The left hand part always creates something.

The right hand part mandates what should be added to it as children - and
these things must be created by some other fragment in the input.

You can put lots of these lines into a file and have the builder consume the
lot. The order of the lines doesn't matter. In fact you can split it over
multiple files to modularise it however you think fit, and give the builder a
whole directory to play with. The builder will consume all the files in the
directory and sub directories.

The format appears to struggle with long lists of children, but it doesn't
because the children can span multiple lines if required.

    VBOX:my_page          row_a         row_b           row_c
                          row_d         row_e           row_f
                          row_g         
    HBOX:row_a ... 

You can also pass it string literals from Python like this (below), which is
conventient to build layouts for individual widgets.

    layout = build_layout(
        """
        VBOX:my_page          header_row    body            footer_row
        HBOX:header_row       left_bit      middle_bit      right_bit
        """

What can it make automatically (apart from QBoxLayouts)
-------------------------------------------------------
The full set of keywords you can use in the left column is: 

    VBOX, HBOX, STACK, TAB, SPLIT 

    (The last two of these are QWidgtet, not QLayouts.)

But you are not limited to the keywords. You could have written this instead:

    QVBoxLayout:my_page          row_a         row_b           row_c

We provided the shorthand keywords like HBOX just to save typing, and to avoid
fretting over correct camel-case names. And because
these are by far the most commonly used Qt classes for building layouts. But
you can use any Qt widget or layout class name. Just bear in mind with your
choice, that the builder will call addWidget() or addLayout() on it if you
have specified any children on the right.  (You don't have to specify any
children).

This makes it easy to add things like labels and buttons at the leaf-level of
the layout hierarchy:

        HBOX:header_row       left_bit      my_label      right_bit
        QLabel:my_label

See next section for accessing the label afterwards to put some text on it.

Accessing the components put into the layout
--------------------------------------------
You'll often need to access the components incorporated into the layout post
build.  So the builder exposes them like this:

    layouts_built.my_page or
    layouts_built.my_label

Note this implies all the names you use on the left hand side in your input 
text must be globally unique. The builder will tell you politely when this
is not so. This is unfortunate, but a deliberate trade-off. We could have
avoided the problem by exposing the components hierarchically:

    layouts_built.my_page.header_row

But that creates unecessary work later, if you decide to move things around in the hiearchy
- and we wanted to keep this really easy to do.

Not just one big layout
-----------------------
Sometimes you'll want to get the builder to make a set of layouts and sub
layouts that you'll combine manually later. Particlarly when you're
introducing it incrementally to existing code.

You don't have to do anything extra to achieve this - the number of layouts
you get is defined by the connectivities you've specified in your input text.
If it all resolves to one big tree then you get one layout. If it resolves to
two seperate trees then you get two trees. You access them as described above:

    layouts_built.my_main_layout
    layouts_built.my_auxillary_layout

If you intended to make one layout but find you've missed something, and
ended up with two, it's
useful for debugging, to visualize the trees as the builder sees them. You can 
ask the builder for a string representation like this:

    layouts_built.get_layout_hierarchy_map()


Using widgets you made earlier (or layouts)
-------------------------------------------
Many custom widgets and layouts need to be constructed and instantiated by
hand. And when you're introducing the builder to existing code bases
incrementatlly, your program will likely want to instantiate many outside of
the builder, but then have the builder use them.

When the builder goes about making the things on the left hand side, it can
pick up instead a pre-existing object that you've pre-instantiated somewhere
else in your program.

    Find:CustomLayout:my_page          header_row    body            footer_row

This behaviour kicks in when you use the double-colon construct shown. The
builder will consider all the objects that are already instantiated in your
program which are of the CustomLayout class. It will then look for one that
you have referenced with a variable or attribute called 'my_page'. For example
Somewhere else in your program you wrote:

    my_page = CustomLayout(arg1, arg2, etc), or
    some_object.my_page = CustomLayout(arg1, arg2, etc), or

If more than one object qualifies - the builder will object politely.

Keywords for Children
----------------------
These exist so far just for one special case that is so completely
ubiquitous it merits it. Ie. you nearly always want to add a stretch item to a box layout
either at one end or the other, or somewhere in the middle of the children:

    HBOX:my_box   foo bar <> baz

The '<>' means put a stretch item here. If you use it on anything other than
HBOX or VBOX, the builder will complain.

How is input text parsed / what are the rules?
----------------------------------------------

See inputsplitter comments.